datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum OrderSource {
  CUSTOMER
  MANUAL
}

enum UserRole {
  CUSTOMER
  STORE_OWNER
  ADMIN
}

enum OrderStatus {
  PENDING
  ACCEPTED
  IN_PREPARATION
  READY_FOR_COLLECTION
  OUT_FOR_DELIVERY
  COMPLETED
  CANCELLED
}

enum FulfilmentType {
  COLLECTION
  DELIVERY
}

enum PaymentMethod {
  CASH_ON_DELIVERY
  CASH_ON_COLLECTION
}

model User {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  clerkUserId String   @unique
  role        UserRole
  name        String
  email       String   @unique
  phone       String?

  // A store owner owns at most one store (MVP)
  store       Store?   @relation("StoreOwner")

  orders      Order[]  @relation("CustomerOrders")

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  Phone Phone[]

  Email Email[]

  Cart Cart[]
}

model Store {
  id                 String     @id @default(auto()) @map("_id") @db.ObjectId
  name               String
  slug               String     @unique
  description        String?
  address            String
  city               String
  area               String
  avgPrepTimeMinutes Int        @default(25)
  creditCents        Int      @default(5000)
  isOpen             Boolean    @default(true)

  // Owner lives here (FK on Store side)
  owner   User   @relation("StoreOwner", fields: [ownerId], references: [id])
  ownerId String @db.ObjectId @unique

  products  Product[]
  orders    Order[]
  LedgerEntry LedgerEntry[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([isOpen])
  Email Email[]
}

model Product {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  store       Store    @relation(fields: [storeId], references: [id])
  storeId     String   @db.ObjectId

  name        String
  description String?
  priceCents  Int
  imageUrl    String?
  isAvailable Boolean  @default(true)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  orderItems  OrderItem[]

  @@index([storeId])
  @@index([storeId, name])
  CartItem CartItem[]
}

model Order {
  id               String        @id @default(auto()) @map("_id") @db.ObjectId
  store            Store         @relation(fields: [storeId], references: [id])
  storeId          String        @db.ObjectId

  customer         User?         @relation("CustomerOrders", fields: [customerId], references: [id])
  customerId       String?       @db.ObjectId

  customerName     String?
  customerPhone    String?
  customerEmail    String?
  fulfilmentType   FulfilmentType
  paymentMethod    PaymentMethod @default(CASH_ON_DELIVERY)
  status           OrderStatus   @default(PENDING)

  totalCents       Int
  platformFeeCents Int?            // amount platform charges (10% of underlying store amount)
  platformFeePaid  Boolean @default(false) // becomes true when we deduct from store credit
  deliveryAddress  String?
  note             String?

  source           OrderSource   @default(CUSTOMER)
  createdByOwnerId String?       @db.ObjectId  // owner who created order (if source = MANUAL)


  pickupCode       String        @unique
  trackingToken    String        @unique

  // ðŸ‘‡ NEW: client-provided idempotency key for checkout
  idempotencyKey   String?       @unique
  
  estimatedReadyAt DateTime?
  completedAt      DateTime?

  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  items            OrderItem[]
  Email Email[]

  @@index([storeId])
  @@index([status])
  @@index([storeId, status])
}

model OrderItem {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  order      Order    @relation(fields: [orderId], references: [id])
  orderId    String   @db.ObjectId

  product    Product  @relation(fields: [productId], references: [id])
  productId  String   @db.ObjectId

  name       String
  quantity   Int
  unitCents  Int
  totalCents Int

  @@index([orderId])
  @@index([productId])
}

enum LedgerType {
  FEE_RESERVE       // reserved when order created (not yet debited)
  FEE_DEBIT         // actual debit to store balance when fee is captured
  TOPUP             // store top up (owner payment)
  REFUND            // refund / reversal
  PAYOUT            // payout from platform to store (if you ever implement payouts)
  ADJUSTMENT        // manual admin adjustment
}

enum LedgerStatus {
  PENDING
  COMPLETED
  FAILED
}

model LedgerEntry {
  id           String     @id @default(auto()) @map("_id") @db.ObjectId
  store        Store      @relation(fields: [storeId], references: [id])
  storeId      String     @db.ObjectId
  type         LedgerType
  status       LedgerStatus @default(PENDING)
  orderId      String?    @db.ObjectId   // optional: which order created this
  amountCents  Int        // positive values: interpretation per type (FEE_DEBIT reduces balance)
  balanceCents Int?       // snapshot of store.creditCents after this entry (if known)
  
  //Top ups
  provider      String?
  checkoutId    String?
  
  note         String?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @default(now())

  @@index([storeId])
  @@index([orderId])
  @@index([type])
}

model Phone {
  id           String  @id @default(auto()) @map("_id") @db.ObjectId
  user         User    @relation(fields: [userId], references: [id])
  userId       String  @db.ObjectId
  phoneNumber  String  @unique
  verified     Boolean @default(false)
}

model PhoneVerification {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  userId      String   @db.ObjectId
  phoneNumber String   @unique
  codeHash    String
  attempts    Int      @default(0)
  maxAttempts Int      @default(5)
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}


enum EmailStatus {
  PENDING   // created, queued for sending
  SENDING   // QStash handler picked it up
  SENT      // successfully sent
  FAILED    // all attempts failed (or latest call failed)
}

model Email {
  id        String      @id @default(auto()) @map("_id") @db.ObjectId

  type      String                      // e.g. "ORDER_CONFIRMATION"
  to        String                      // destination email
  subject   String
  status    EmailStatus @default(PENDING)
  attempts  Int         @default(0)
  lastError String?

  // Optional linking (nice for multi-tenant + debugging)
  order     Order?      @relation(fields: [orderId], references: [id])
  orderId   String?     @db.ObjectId

  store     Store?      @relation(fields: [storeId], references: [id])
  storeId   String?     @db.ObjectId

  user      User?       @relation(fields: [userId], references: [id])
  userId    String?     @db.ObjectId

  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  @@index([to])
  @@index([type])
  @@index([status])
  @@index([orderId])
  @@index([storeId])
}

model Cart {
  id         String     @id @default(auto()) @map("_id") @db.ObjectId
  customer   User?      @relation(fields: [customerId], references: [id])
  customerId String?    @db.ObjectId
  items      CartItem[]

  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  @@index([customerId])
}

model CartItem {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  cart       Cart     @relation(fields: [cartId], references: [id])
  cartId     String   @db.ObjectId

  product    Product  @relation(fields: [productId], references: [id])
  productId  String   @db.ObjectId

  quantity   Int

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // One row per product per cart â€“ important for atomic upserts later
  @@unique([cartId, productId])
  @@index([cartId])
}
